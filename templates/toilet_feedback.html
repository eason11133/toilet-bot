<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title id="t_title">{{ toilet_name }} å›é¥‹</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f9; color: #333; }
        h2 { color: #2C3E50; margin-bottom: 6px; }
        .addr { color: #666; margin-top: 0; }
        .cleanliness-score { background-color: #e0f7fa; padding: 10px; border-left: 5px solid #00acc1; margin: 15px 0; font-weight: bold; }
        .nowcast-box { background:#fff7e6; padding:10px; border-left:5px solid #ff9800; margin:12px 0; }
        .summary-box { background: #fff; border-radius: 8px; padding: 10px 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); white-space: pre-line; }
        .section-title { margin-top: 24px; font-weight: bold; color: #2C3E50; }
        ul { list-style-type: none; padding: 0; }
        li { background-color: #fff; margin: 10px 0; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }
        .toggle-button { background: none; border: none; color: #007BFF; cursor: pointer; font-size: 1em; margin-bottom: 10px; }
        .comment { font-style: italic; color: #888; }
        .collapsed { display: none; }
        .no-feedback { color: #999; }
        #cleanlinessChart { width: 100%; height: 300px; margin-top: 14px; }
        .muted { color:#888; font-size: 12px; }
        .meta { color:#555; }
    </style>
    <script src="https://static.line-scdn.net/liff/edge/versions/2.23.0/sdk.js"></script>
</head>
<body>
    <h2 id="t_h2">{{ toilet_name }}</h2>
    {% if address %}<p class="addr">{{ address }}</p>{% endif %}

    <div class="cleanliness-score">
        <span id="t_avg_label">å¹³å‡é æ¸¬æ¸…æ½”åˆ†æ•¸(æœ€é«˜5åˆ†)ï¼š</span><span id="avgPredScore">æœªé æ¸¬</span>
    </div>

    <div class="nowcast-box">
        <div id="nowcastText">å³æ™‚æ¸…æ½”æŒ‡æ•¸è¼‰å…¥ä¸­â€¦</div>
        <div class="muted" id="t_nowcast_note">* ä»¥ä¸Šç‚ºæœ€è¿‘å›é¥‹çš„å³æ™‚ä¼°è¨ˆï¼Œæ‹¬è™Ÿç‚º 95% ä¿¡è³´å€é–“ï¼›n ç‚ºç´å…¥è¨ˆç®—çš„ç­†æ•¸</div>
    </div>

    {% if summary %}
      <div class="summary-box">{{ summary }}</div>
    {% endif %}

    <div class="section-title" id="t_trend">æ¸…æ½”åº¦è¶¨å‹¢</div>
    <canvas id="cleanlinessChart"></canvas>

    <div class="section-title" id="t_feedbacks">ä½¿ç”¨è€…å›é¥‹</div>
    {% if feedbacks and feedbacks|length > 0 %}
        {% if feedbacks|length > 1 %}
            <button class="toggle-button" id="toggleBtn">â–¶ï¸ å±•é–‹å…¶ä»– {{ feedbacks|length - 1 }} ç­†ä½¿ç”¨è€…å›é¥‹</button>
        {% endif %}
        <ul id="feedbackList">
            <li>
                <p class="meta">
                    <strong>ğŸŒŸ <span class="t_rate">è©•åˆ†:</span></strong> {{ feedbacks[0].rating }} ï½œ 
                    <strong>ğŸ§» <span class="t_paper">è¡›ç”Ÿç´™:</span></strong> {{ feedbacks[0].toilet_paper }} ï½œ 
                    <strong>â™¿ <span class="t_access">ç„¡éšœç¤™è¨­æ–½:</span></strong> {{ feedbacks[0].accessibility }} ï½œ 
                    <strong>ğŸ•’ <span class="t_time">ä½¿ç”¨æ™‚é–“:</span></strong>
                      <span class="v_time">{{ feedbacks[0].time_of_use or 'æœªå¡«å¯«' }}</span> ï½œ 
                    <strong>ğŸ¢ <span class="t_floor">ä½ç½®/æ¨“å±¤:</span></strong>
                      <span class="v_floor">{{ feedbacks[0].floor or 'æ¨“å±¤æœªçŸ¥' }}</span>
                </p>
                <p class="comment">
                    <strong>ğŸ’¬ <span class="t_comment">ç•™è¨€:</span></strong>
                    {% if feedbacks[0].comment and feedbacks[0].comment.strip() %}
                        {{ feedbacks[0].comment }}
                    {% else %}
                        <span class="v_comment_empty">ï¼ˆç„¡ç•™è¨€ï¼‰</span>
                    {% endif %}
                </p>
                <p style="color:#999;">ğŸ“… {{ feedbacks[0].created_at }}</p>
            </li>

            {% for c in feedbacks[1:] %}
                <li class="collapsed">
                    <p class="meta">
                        <strong>ğŸŒŸ <span class="t_rate">è©•åˆ†:</span></strong> {{ c.rating }} ï½œ 
                        <strong>ğŸ§» <span class="t_paper">è¡›ç”Ÿç´™:</span></strong> {{ c.toilet_paper }} ï½œ 
                        <strong>â™¿ <span class="t_access">ç„¡éšœç¤™è¨­æ–½:</span></strong> {{ c.accessibility }} ï½œ 
                        <strong>ğŸ•’ <span class="t_time">ä½¿ç”¨æ™‚é–“:</span></strong>
                          <span class="v_time">{{ c.time_of_use or 'æœªå¡«å¯«' }}</span> ï½œ 
                        <strong>ğŸ¢ <span class="t_floor">ä½ç½®/æ¨“å±¤:</span></strong>
                          <span class="v_floor">{{ c.floor or 'æ¨“å±¤æœªçŸ¥' }}</span>
                    </p>
                    <p class="comment">
                        <strong>ğŸ’¬ <span class="t_comment">ç•™è¨€:</span></strong>
                        {% if c.comment and c.comment.strip() %}
                            {{ c.comment }}
                        {% else %}
                            <span class="v_comment_empty">ï¼ˆç„¡ç•™è¨€ï¼‰</span>
                        {% endif %}
                    </p>
                    <p style="color:#999;">ğŸ“… {{ c.created_at }}</p>
                </li>
            {% endfor %}
        </ul>
    {% else %}
        <ul><li class="no-feedback" id="t_no_feedback">ï¼ˆç›®å‰å°šç„¡ä»»ä½•å›é¥‹ï¼‰</li></ul>
    {% endif %}

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        /** ===== i18n ===== */
        const I18N = {
          zh: {
            title_suffix: " å›é¥‹",
            avg_label: "å¹³å‡é æ¸¬æ¸…æ½”åˆ†æ•¸(æœ€é«˜5åˆ†)ï¼š",
            not_pred: "æœªé æ¸¬",
            nowcast_loading: "å³æ™‚æ¸…æ½”æŒ‡æ•¸è¼‰å…¥ä¸­â€¦",
            nowcast_note: "* ä»¥ä¸Šç‚ºæœ€è¿‘å›é¥‹çš„å³æ™‚ä¼°è¨ˆï¼Œæ‹¬è™Ÿç‚º 95% ä¿¡è³´å€é–“ï¼›n ç‚ºç´å…¥è¨ˆç®—çš„ç­†æ•¸",
            trend: "æ¸…æ½”åº¦è¶¨å‹¢",
            feedbacks: "ä½¿ç”¨è€…å›é¥‹",
            toggle_prefix: "â–¶ï¸ å±•é–‹å…¶ä»– ",
            toggle_suffix: " ç­†ä½¿ç”¨è€…å›é¥‹",
            rating: "è©•åˆ†:",
            paper: "è¡›ç”Ÿç´™:",
            access: "ç„¡éšœç¤™è¨­æ–½:",
            time: "ä½¿ç”¨æ™‚é–“:",
            floor: "ä½ç½®/æ¨“å±¤:",
            comment: "ç•™è¨€:",
            time_na: "æœªå¡«å¯«",
            floor_na: "æ¨“å±¤æœªçŸ¥",
            no_comment: "ï¼ˆç„¡ç•™è¨€ï¼‰",
            no_feedback: "ï¼ˆç›®å‰å°šç„¡ä»»ä½•å›é¥‹ï¼‰",
            chart_label: "æ¸…æ½”åº¦é æ¸¬",
            x_title: "å›é¥‹æ¬¡æ•¸",
            y_title: "æ¸…æ½”åº¦",
            nowcast_none: "å³æ™‚æ¸…æ½”æŒ‡æ•¸ï¼šå°šç„¡å³æ™‚è³‡æ–™",
            nowcast_fmt: (mean, lower, upper, n) => `å³æ™‚æ¸…æ½”æŒ‡æ•¸ï¼š${mean} åˆ†ï¼ˆ95% CIï¼š${lower}â€“${upper}ï¼Œn=${n}ï¼‰`,
            nowcast_fail: "å³æ™‚æ¸…æ½”æŒ‡æ•¸ï¼šè¼‰å…¥å¤±æ•—"
          },
          en: {
            title_suffix: " Feedback",
            avg_label: "Average predicted cleanliness (max 5): ",
            not_pred: "N/A",
            nowcast_loading: "Loading real-time cleanlinessâ€¦",
            nowcast_note: "* Real-time estimate from recent feedback. Parentheses show 95% CI; n is the sample size.",
            trend: "Cleanliness Trend",
            feedbacks: "User Feedback",
            toggle_prefix: "â–¶ï¸ Show ",
            toggle_suffix: " more feedback(s)",
            rating: "Rating:",
            paper: "Toilet paper:",
            access: "Accessibility:",
            time: "Time:",
            floor: "Floor/Location:",
            comment: "Comment:",
            time_na: "Not provided",
            floor_na: "Unknown",
            no_comment: "(No comment)",
            no_feedback: "(No feedback yet)",
            chart_label: "Predicted cleanliness",
            x_title: "Feedback count",
            y_title: "Cleanliness",
            nowcast_none: "Real-time cleanliness: no data yet",
            nowcast_fmt: (mean, lower, upper, n) => `Real-time cleanliness: ${mean} (95% CI: ${lower}â€“${upper}, n=${n})`,
            nowcast_fail: "Real-time cleanliness: failed to load"
          }
        };

        function normLang(x){
          x = (x || "").toLowerCase();
          if (x.startsWith("en")) return "en";
          return "zh";
        }
        function getLang(){
      return normLang(navigator.language || "zh");
}

        const LANG = getLang();
        const T = I18N[LANG] || I18N.zh;

        document.documentElement.lang = (LANG === "en") ? "en" : "zh-Hant";

        // title
        const toiletName = "{{ toilet_name }}";
        document.title = toiletName + T.title_suffix;
        const tTitle = document.getElementById("t_title");
        if (tTitle) tTitle.textContent = toiletName + T.title_suffix;

        // static labels
        const setText = (id, v)=>{ const el=document.getElementById(id); if(el) el.textContent=v; };
        setText("t_avg_label", T.avg_label);
        setText("t_nowcast_note", T.nowcast_note);
        setText("t_trend", T.trend);
        setText("t_feedbacks", T.feedbacks);

        const avgNode = document.getElementById("avgPredScore");
        if (avgNode && (avgNode.textContent || "").trim() === "æœªé æ¸¬") avgNode.textContent = T.not_pred;

        const nowcastBox = document.getElementById("nowcastText");
        if (nowcastBox) nowcastBox.textContent = T.nowcast_loading;

        // translate meta labels
        document.querySelectorAll(".t_rate").forEach(n=>n.textContent = T.rating);
        document.querySelectorAll(".t_paper").forEach(n=>n.textContent = T.paper);
        document.querySelectorAll(".t_access").forEach(n=>n.textContent = T.access);
        document.querySelectorAll(".t_time").forEach(n=>n.textContent = T.time);
        document.querySelectorAll(".t_floor").forEach(n=>n.textContent = T.floor);
        document.querySelectorAll(".t_comment").forEach(n=>n.textContent = T.comment);

        // DO NOT rewrite body HTML; only swap known placeholders
        function swapIfExact(selector, from, to){
          document.querySelectorAll(selector).forEach(el=>{
            if ((el.textContent || "").trim() === from) el.textContent = to;
          });
        }

        if (LANG === "en") {
          swapIfExact(".v_time", "æœªå¡«å¯«", T.time_na);
          swapIfExact(".v_floor", "æ¨“å±¤æœªçŸ¥", T.floor_na);
          swapIfExact(".v_comment_empty", "ï¼ˆç„¡ç•™è¨€ï¼‰", T.no_comment);
          const nf = document.getElementById("t_no_feedback");
          if (nf) nf.textContent = T.no_feedback;
        }

        // toggle button text (pure JS, no Jinja)
        const toggleBtn = document.getElementById("toggleBtn");
        if (toggleBtn) {
          const nMore = document.querySelectorAll("#feedbackList li.collapsed").length;
          toggleBtn.textContent = T.toggle_prefix + nMore + T.toggle_suffix;
        }

        // expand more
        if (toggleBtn) {
          toggleBtn.addEventListener('click', () => {
            document.querySelectorAll('#feedbackList li.collapsed').forEach(li => li.classList.remove('collapsed'));
            toggleBtn.style.display = 'none';
          });
        }

        // coordinates
        function getLatLon() {
            let lat = "{{ lat|default('', true) }}";
            let lon = "{{ lon|default('', true) }}";
            if (lat && lon) return {lat, lon};
            const m = decodeURIComponent(location.pathname).match(/\/toilet_feedback_by_coord\/([^/]+)\/([^/]+)/);
            if (m && m[1] && m[2]) return { lat: m[1], lon: m[2] };
            const addrNode = document.querySelector('.addr');
            if (addrNode) {
                const m2 = (addrNode.textContent || '').match(/(-?\d+\.?\d*),\s*(-?\d+\.?\d*)/);
                if (m2) return { lat: m2[1], lon: m2[2] };
            }
            return {lat:'', lon:''};
        }

        (function drawTrendAndAvg() {
            const { lat, lon } = getLatLon();
            if (!lat || !lon) return;

            fetch(`/get_clean_trend_by_coord/${lat}/${lon}?recompute=1&lang=${encodeURIComponent(LANG)}`)
              .then(r => r.json())
              .then(data => {
                  const arr = (data && data.data) ? data.data : [];
                  const canvas = document.getElementById('cleanlinessChart');
                  if (!canvas) return;
                  const ctx = canvas.getContext('2d');

                  const avgNode = document.getElementById('avgPredScore');
                  if (arr.length > 0) {
                      const avg = (arr.reduce((s,x)=>s + (Number(x.score)||0), 0) / arr.length).toFixed(2);
                      if (avgNode) avgNode.textContent = avg;
                  } else {
                      if (avgNode) avgNode.textContent = T.not_pred;
                  }

                  new Chart(ctx, {
                      type: 'line',
                      data: {
                          labels: arr.map((_, i) => `#${i + 1}`),
                          datasets: [{
                              label: T.chart_label,
                              data: arr.map(x => Number(x.score)||null),
                              borderColor: 'rgba(75, 192, 192, 1)',
                              fill: false,
                              tension: 0.3
                          }]
                      },
                      options: {
                          responsive: true,
                          scales: {
                              x: { title: { display: true, text: T.x_title } },
                              y: { min: 1, max: 5, title: { display: true, text: T.y_title } }
                          }
                      }
                  });
              })
              .catch(err => console.error('trend fetch failed:', err));

            fetch(`/get_nowcast_by_coord/${lat}/${lon}?lang=${encodeURIComponent(LANG)}`)
              .then(r => r.json())
              .then(data => {
                  const box = document.getElementById('nowcastText');
                  if (!box) return;
                  if (!data || data.success === false || (data.n !== undefined && data.n === 0)) {
                      box.textContent = T.nowcast_none;
                      return;
                  }
                  const mean = (data.mean !== undefined) ? Number(data.mean).toFixed(2) : 'â€”';
                  const lower = (data.lower !== undefined) ? Number(data.lower).toFixed(2) : 'â€”';
                  const upper = (data.upper !== undefined) ? Number(data.upper).toFixed(2) : 'â€”';
                  const n = (data.n !== undefined) ? data.n : 0;
                  box.textContent = T.nowcast_fmt(mean, lower, upper, n);
              })
              .catch(err => {
                  console.error('nowcast fetch failed:', err);
                  const box = document.getElementById('nowcastText');
                  if (box) box.textContent = T.nowcast_fail;
              });
        })();
    </script>
</body>
</html>
